## 📚 Part 1: Introduction to Graph Learning
### 2장. 그래프 신경망을 위한 그래프 이론 (Graph Theory for Graph Neural Networks)

> **💻 기술 요구사항**
> 
> 이 장의 모든 코드 예제는 GitHub에서 찾을 수 있습니다:
> https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02

---

#### 📐 1. 그래프 속성 소개 (Introducing graph properties)

그래프 이론에서 그래프는 정점(vertices) 또는 노드(nodes)라고 불리는 객체들의 집합과, 정점 쌍을 연결하는 간선(edges)들의 집합으로 구성된 수학적 구조입니다. 표기법으로는 G = (V, E)를 사용하며, 여기서 G는 그래프, V는 정점 집합, E는 간선 집합입니다.

그래프의 노드는 도시, 사람, 웹 페이지, 분자 등 어떤 객체든 나타낼 수 있고, 간선은 물리적 도로, 사회적 관계, 하이퍼링크, 화학 결합 등 그들 간의 관계나 연결을 나타냅니다.

**그래프 유형별 분류**

| 분류 기준 | 유형 | 특징 |
|-----------|------|------|
| 방향성 | 방향 그래프 | 간선이 방향을 가짐 |
| | 무방향 그래프 | 간선이 방향을 가지지 않음 |
| 가중치 | 가중 그래프 | 간선에 가중치가 있음 |
| | 비가중 그래프 | 간선에 가중치가 없음 |
| 연결성 | 연결 그래프 | 모든 노드 간에 경로가 존재 |
| | 비연결 그래프 | 연결되지 않은 노드가 존재 |

##### 🔄 방향 그래프 vs 무방향 그래프

**무방향 그래프 (Undirected Graph)**
무방향 그래프에서 간선은 방향이 없습니다. 두 정점 간의 간선은 양방향으로 이동할 수 있습니다.

```python
import networkx as nx

# 무방향 그래프 생성
G = nx.Graph()
G.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'),
                  ('B', 'E'), ('C', 'F'), ('C', 'G')])
```

```
    A
   / \
  B   C
 /|\  |\
D E F  G
```

**방향 그래프 (Directed Graph)**
방향 그래프에서 각 간선은 방향이나 방향성을 가집니다. 간선은 특정 방향으로 두 노드를 연결합니다.

```python
# 방향 그래프 생성
DG = nx.DiGraph()
DG.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'),
                   ('B', 'E'), ('C', 'F'), ('C', 'G')])
```

방향 그래프에서는 간선이 화살표로 표시되어 방향을 나타냅니다.

##### ⚖️ 가중 그래프 (Weighted Graphs)

가중 그래프에서 각 간선은 가중치나 비용이 관련되어 있습니다. 이 가중치는 거리, 이동 시간, 비용 등을 나타낼 수 있습니다.

```python
# 가중 그래프 생성
WG = nx.Graph()
WG.add_edges_from([('A', 'B', {"weight": 10}), ('A', 'C', {"weight": 20}),
                   ('B', 'D', {"weight": 30}), ('B', 'E', {"weight": 40}),
                   ('C', 'F', {"weight": 50}), ('C', 'G', {"weight": 60})])

# 가중치 라벨 가져오기
labels = nx.get_edge_attributes(WG, "weight")
```

##### 🔗 연결 그래프 (Connected Graphs)

**연결 그래프의 정의**
- 연결 그래프: 그래프의 임의의 두 정점 사이에 경로가 존재
- 비연결 그래프: 연결되지 않은 그래프로, 최소 두 개의 정점이 경로로 연결되지 않음

```python
# 비연결 그래프 예제
G1 = nx.Graph()
G1.add_edges_from([(1, 2), (2, 3), (3, 1), (4, 5)])
print(f"그래프 1이 연결되어 있나요? {nx.is_connected(G1)}")

# 연결 그래프 예제
G2 = nx.Graph()
G2.add_edges_from([(1, 2), (2, 3), (3, 1), (1, 4)])
print(f"그래프 2가 연결되어 있나요? {nx.is_connected(G2)}")
```

출력:
```
그래프 1이 연결되어 있나요? False
그래프 2가 연결되어 있나요? True
```

**연결 그래프의 특징**
- 통신 네트워크에서 연결 그래프는 임의의 두 노드가 경로를 통해 서로 통신할 수 있음을 보장
- 비연결 그래프는 네트워크의 다른 노드와 통신할 수 없는 고립된 노드를 가질 수 있음

##### 🏗️ 특수 그래프 구조

**다양한 그래프 유형**

| 그래프 유형 | 특징 | 응용 분야 |
|-------------|------|-----------|
| **트리 (Tree)** | 연결된 무방향 그래프로 사이클이 없음 | 가족 트리, 조직 구조, 분류 트리 |
| **루트 트리 (Rooted Tree)** | 하나의 노드를 루트로 지정한 트리 | 파일시스템, XML 문서 구조 |
| **DAG (Directed Acyclic Graph)** | 사이클이 없는 방향 그래프 | 프로젝트 관리, 작업의 임계 경로 계산 |
| **이분 그래프 (Bipartite Graph)** | 정점을 두 개의 분리된 집합으로 나눌 수 있는 그래프 | 구매자-판매자, 직원-프로젝트 관계 |
| **완전 그래프 (Complete Graph)** | 모든 정점 쌍이 간선으로 연결된 그래프 | 조합론, 완전 연결 네트워크 |

---

#### 🔍 2. 그래프 개념 발견 (Discovering graph concepts)

이 섹션에서는 그래프 이론의 핵심 개념들을 탐색합니다. 그래프 객체(차수, 이웃 등), 그래프 측정(중심성, 밀도), 인접 행렬 표현을 포함합니다.

##### 📊 기본 객체 (Fundamental objects)

**노드 차수 (Node Degree)**
노드의 차수는 해당 노드에 연결된 간선의 수입니다. 노드 v의 차수는 deg(v)로 표시됩니다.

**무방향 그래프의 차수**
- 정점의 차수는 그 정점에 연결된 간선의 수
- 자기 루프(self-loop)가 있는 경우 차수에 2를 더함

**방향 그래프의 차수**
- **진입 차수 (Indegree)**: 노드를 향하는 간선의 수 (deg⁻(v))
- **출입 차수 (Outdegree)**: 노드에서 시작하는 간선의 수 (deg⁺(v))

```python
# 무방향 그래프의 차수 계산
G = nx.Graph()
G.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), 
                  ('C', 'F'), ('C', 'G')])
print(f"deg(A) = {G.degree['A']}")

# 방향 그래프의 진입/출입 차수 계산
DG = nx.DiGraph()
DG.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), 
                   ('C', 'F'), ('C', 'G')])
print(f"deg⁻(A) = {DG.in_degree['A']}")
print(f"deg⁺(A) = {DG.out_degree['A']}")
```

출력:
```
deg(A) = 2
deg⁻(A) = 0
deg⁺(A) = 2
```

**이웃 (Neighbors)**
이웃은 간선을 통해 특정 노드에 직접 연결된 노드들을 의미합니다.

**경로 (Path)**
경로는 그래프에서 두 개 이상의 노드를 연결하는 간선들의 순서입니다.

- **단순 경로 (Simple Path)**: 시작과 끝 정점을 제외하고 어떤 노드도 한 번 이상 방문하지 않는 경로
- **사이클 (Cycle)**: 첫 번째와 마지막 정점이 같은 경로
- **비순환 그래프 (Acyclic Graph)**: 사이클을 포함하지 않는 그래프

##### 📏 그래프 측정 (Graph measures)

**중심성 (Centrality)**
중심성은 네트워크에서 정점이나 노드의 중요성을 정량화합니다.

**1. 차수 중심성 (Degree Centrality)**
가장 간단한 중심성 측정으로, 노드의 차수로 정의됩니다.

```python
print(f"차수 중심성 = {nx.degree_centrality(G)}")
```

**2. 근접성 중심성 (Closeness Centrality)**
노드가 그래프의 다른 모든 노드에 얼마나 가까운지를 측정합니다.

```python
print(f"근접성 중심성 = {nx.closeness_centrality(G)}")
```

**3. 매개 중심성 (Betweenness Centrality)**
노드가 그래프의 다른 노드 쌍 간의 최단 경로에 얼마나 자주 포함되는지를 측정합니다.

```python
print(f"매개 중심성 = {nx.betweenness_centrality(G)}")
```

**밀도 (Density)**
그래프의 연결 정도를 나타내는 척도로, 실제 간선 수와 최대 가능한 간선 수의 비율입니다.

> **그래프 밀도 공식**
> 
> 밀도 = 실제 간선 수 / 최대 가능한 간선 수
> 
> - 무방향 그래프: 최대 간선 수 = n(n-1)/2
> - 방향 그래프: 최대 간선 수 = n(n-1)

- **밀집 그래프 (Dense Graph)**: 밀도가 1에 가까움 (일반적으로 > 0.5)
- **희소 그래프 (Sparse Graph)**: 밀도가 0에 가까움 (일반적으로 < 0.1)

##### 📊 인접 행렬 표현 (Adjacency Matrix Representation)

인접 행렬은 그래프의 간선을 나타내는 행렬로, 각 셀은 두 노드 간에 간선이 있는지 여부를 나타냅니다.

**인접 행렬의 특징**
- n×n 정사각 행렬 (n은 노드 수)
- 셀 (i, j)의 값이 1이면 노드 i와 j 간에 간선이 존재
- 셀 (i, j)의 값이 0이면 간선이 없음
- 무방향 그래프에서는 대칭 행렬

```python
# 인접 행렬 예제
adj = [[0,1,1,0,0,0,0],
       [1,0,0,1,1,0,0],
       [1,0,0,0,0,1,1],
       [0,1,0,0,0,0,0],
       [0,1,0,0,0,0,0],
       [0,0,1,0,0,0,0],
       [0,0,1,0,0,0,0]]
```

**인접 행렬의 장단점**

| 장점 | 단점 |
|------|------|
| 두 노드 연결 확인이 O(1) 시간 | 공간 복잡도 O(|V|²) |
| 행렬 연산 수행 가능 | 노드 추가/제거 시 비용 높음 |
| 작은 그래프에 효율적 | 큰 그래프에는 비실용적 |

**대안적 표현 방법**

**1. 간선 리스트 (Edge List)**
```python
edge_list = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)]
```
- 공간 복잡도: O(|E|)
- 희소 그래프에 효율적

**2. 인접 리스트 (Adjacency List)**
```python
adj_list = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5, 6],
    3: [1],
    4: [1],
    5: [2],
    6: [2]
}
```
- 공간 복잡도: O(|V| + |E|)
- 희소 그래프에 최적

---

#### 🔬 3. 그래프 알고리즘 탐색 (Exploring graph algorithms)

그래프 알고리즘은 두 노드 간의 최단 경로 찾기나 사이클 감지 등 그래프와 관련된 문제를 해결하는 데 중요합니다. 이 섹션에서는 두 가지 기본적인 그래프 순회 알고리즘인 (BFS와 DFS)[https://velog.io/@yujin_jeong/BFS-vs-DFS]를 다룹니다.

##### 🔍 너비 우선 탐색 (Breadth-First Search, BFS)
BFS는 루트 노드에서 시작하여 특정 레벨의 모든 인접 노드를 탐색한 후 다음 레벨의 노드로 이동하는 그래프 순회 알고리즘입니다.

**BFS 알고리즘 동작 과정**

```
시작: A
Level 0: [A]
Level 1: [B, C]  (A의 이웃들)
Level 2: [D, E, F, G]  (B, C의 이웃들)
```

**BFS 시각화 다이어그램**
```
    A (시작)
   / \
  B   C
 /|\  |\
D E F  G

탐색 순서: A → B → C → D → E → F → G
```

**Python 구현**
```python
def bfs(graph, node):
    # 방문한 노드와 큐 초기화
    visited, queue = [node], [node]
    
    while queue:
        # 큐에서 첫 번째 노드 제거
        node = queue.pop(0)
        
        # 현재 노드의 모든 이웃 탐색
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.append(neighbor)
                queue.append(neighbor)
    
    return visited
```

**BFS의 특징**
- **최단 경로**: 무가중 그래프에서 두 노드 간의 최단 경로 찾기
- **연결성 확인**: 그래프가 연결되어 있는지 확인
- **시간 복잡도**: O(|V| + |E|)

**BFS 응용 분야**
- 웹 크롤러
- 소셜 네트워크 분석
- 네트워크의 최단 경로 라우팅

##### 🔍 깊이 우선 탐색 (Depth-First Search, DFS)

DFS는 루트 노드에서 시작하여 각 분기를 가능한 한 깊이 탐색한 후 백트래킹하는 재귀적 알고리즘입니다.

**DFS 알고리즘 동작 과정**

```
시작: A
A → B → D (깊이 우선)
    ↓
    E (백트래킹 후)
    ↓
    C → F (깊이 우선)
        ↓
        G (백트래킹 후)
```

**DFS 시각화 다이어그램**
```
    A (시작)
   / \
  B   C
 /|\  |\
D E F  G

탐색 순서: A → B → D → E → C → F → G
```

**Python 구현**
```python
def dfs(visited, graph, node):
    # 현재 노드가 방문되지 않았다면 방문 목록에 추가
    if node not in visited:
        visited.append(node)
        
        # 현재 노드의 모든 이웃에 대해 재귀적으로 DFS 수행
        for neighbor in graph[node]:
            visited = dfs(visited, graph, neighbor)
    
    return visited
```

**DFS의 특징**
- **재귀적 구조**: 자연스러운 재귀 구현
- **메모리 효율성**: BFS보다 적은 메모리 사용
- **사이클 감지**: 그래프에서 사이클 찾기에 유용
- **시간 복잡도**: O(|V| + |E|)

**DFS 응용 분야**
- 연결 요소 찾기
- 위상 정렬
- 미로 문제 해결
- 사이클 감지

**BFS vs DFS 비교**

| 특성 | BFS | DFS |
|------|-----|-----|
| **탐색 방식** | 레벨별 탐색 | 깊이 우선 탐색 |
| **메모리 사용** | 큐 사용 (더 많은 메모리) | 스택 사용 (적은 메모리) |
| **최단 경로** | 보장됨 | 보장되지 않음 |
| **적합한 문제** | 최단 경로, 연결성 확인 | 사이클 감지, 위상 정렬 |

**고급 그래프 알고리즘**
BFS와 DFS는 다음과 같은 고급 알고리즘의 기반이 됩니다:
- **Dijkstra의 최단 경로 알고리즘**
- **Kruskal의 최소 신장 트리 알고리즘**
- **Tarjan의 강연결 요소 알고리즘**

---

#### 🔬 실습: 그래프 데이터셋 분석

### 📊 주요 데이터셋

#### 1. Cora 데이터셋
- **구성**: 2,708개의 과학 논문 네트워크
- **노드**: 논문 (1,433개 고유 단어의 이진 벡터)
- **에지**: 인용 관계
- **클래스**: 7개 카테고리

#### 2. Facebook Page-Page 데이터셋
- **구성**: 22,470개의 공식 페이스북 페이지
- **노드**: 페이지 (128차원 벡터)
- **에지**: 상호 좋아요 관계
- **클래스**: 4개 카테고리 (정치인, 기업, TV 프로그램, 정부기관)
